# JJSang Notes




<!-- markdown-toc end -->


## 🧮 数据结构 & 算法（程序 = 数据结构 + 算法）

#### 二叉查找树的时间复杂度是多少？
> 平衡状态下为 `O(logn)` 节点分布失衡会退化到 O(n) 在一条链上  

#### 在 `O(logn)` 中的 log 是以什么为底？  
> 以 2 为底 n 的对数 = 以 2 为底 10 的对数 * 以 10 为底 n 的对数  
> 以 2 为底 10 的对数是一个常数，这里忽略常数项系数  
> log 以 i 为底 n 的对数等于 log 以 j 为底 n 的对数，所以忽略了 i，直接说是logn

#### 这里的 n 是指？
> n 个节点

#### 二叉查找树和二分法哪个速度更快？
> 两者时间复杂度都是 O(logn)  
> 两者明显的区别是二分查找速度快删除和插入困难，对于建立的二叉树索引来说，他的插入和删除是相对较快的。

#### 为什么会出现这两者的差别？
> 从空间性能，顺序存储会对空间资源做到百分之百的利用，而链式存储对对空间的利用不是百分之百，因为存储了指针，不是真正的数据；  
> 从时间性能上来讲读取速度的话顺序存储更优，插入和删除操作链式存储更优，链式存储只需要移动指针，不需要移动元素。

#### 什么时候采用二分什么时候采用二叉索引？
> 如果数据是不进行频繁变化且是有序，而且查询相对较多的情况下采用二分查找；  
> 数据是频繁变化的考虑到后面的数据扩容的情况下，考虑采用二叉索引的方式，但是会有一点空间资源的牺牲。

#### 二叉树的遍历方式有哪些？实现一下代码？
> 前、中、后序遍历
```python
# 二叉树中序遍历的递归 value  left  right
def inorder(root):
    if not root:
        return 
    inorder(root.left)
    print(root.val)
    inorder(root.right)
    
# 二叉树先序遍历的递归 left  value  right
def preorder(root):
    if not root:
        return 
    print(root.val)
    preorder(root.left)
    preorder(root.right)
   
# 二叉树后序遍历的递归 left  right value
def postorder(root):
    if not root:
        return 
    postorder(root.left)
    postorder(root.right)
    print(root.val)
```
#### 怎么判断二叉树平衡？
> 左右两个子树的高度差的绝对值均不超过 1

#### 什么是平衡二叉树？
> 平衡二叉树又叫 AVL 树，是一种特殊的二叉查找树，可以自动调节平衡。  
> AVL 树维持着严格的平衡，任意节点两颗子树的高度差都不超过 1。  
> 优点是保证了查询效率，缺点是维持平衡成本较高，适合查询较多的场景。

#### 什么是红黑树？
> 是另一种可以自动调整平衡的二叉查找树。优点是降低了维持平衡的成本，缺点是查询效率底，适合频繁插入删除的场景。

#### 红黑树和AVL树的不同?
> AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；  
> 红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；

#### 红黑树有什么更深刻理解?
> 红黑树详解: https://xieguanglei.github.io/blog/post/red-black-tree.html

#### 什么是B树和B+树？
> B树解决了从磁盘海量数据中查询的需求，有效减少了磁盘 I/O 的频次。  
> B+树是B树的升级，叶子结点包括全量数据，并使用双向指针连接相邻节点，为范围查询提供了便利。

#### 如何快速判断一个数是奇数还是偶数，除了对2取余?
> 与1相与。 `return 奇数 if( x & 1 ) else 偶数`

## ☁️ 计算机网络

#### 为什么有 TCP/IP 四层模型？  
> OSI 七层协议体系结构的概念清楚，理论也比较完整，但它既复杂又不实用 

#### 对 TCP/IP 四层模型的理解？
> ![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220705105059.png)    
> 应用层（数据段）  
> 传输层（数据包）  
> 网络层（数据帧）  
> 数据链路层（比特流）

#### 对 OSI 七层模型的理解？
- 应用层（文件传输，电子邮件，文件服务，虚拟终端）  
TCP/IP 协议：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
- 表示层（数据格式化，代码转换，数据加密）  
TCP/IP 协议：没有协议
- 会话层（解除或建立与别的接点的联系）  
TCP/IP 协议：没有协议
- 传输层（提供端对端的接口）  
TCP/IP 协议：TCP，UDP

  |            | TCP（Transmission Control Protocol）             | UDP                                        |
  | ---------- | ------------------------------------------------ | ------------------------------------------ |
  | 可靠性     | 可靠                                             | 不可靠                                     |
  | 连接性     | 面向连接                                         | 无连接                                     |
  | 效率       | 传输效率低                                       | 传输效率高                                 |
  | 双工性     | 全双工                                           | 一对一、一对多、多对一、多对多             |
  | 传输速度   | 慢                                               | 快                                         |
  | 应用场景   | 对效率要求低，对准确性要求高或者要求有链接的场景 | 对效率要求高，对准确性要求低的场景         |
  | 应用层协议 | SMTP电子邮件/HTTP万维网/FTP文件传输              | DNS域名转换/TFTP文件传输/NFS远程文件服务器 |

- 网络层（为数据包选择路由）  
TCP/IP 协议：IP，ICMP，RIP，OSPF，BGP，IGMP
  - 路由器	拥有独立MAC帮助转发，本身没有传输包的功能实际传输是委托给数据链路层的
  - IP协议是不可靠协议，数据处理被认为是上层协议要做的事
  - 32位IP地址分为网络位和地址位，这样可以减少路由表记录的数目
    - A类IP地址：0.0.0.0 ～ 1 27.0.0.0
    - B类IP地址：128.0.0.1 ～ 191.255.0.0
    - C类IP地址：192.168.0.0 ～ 239.255.255.0
- 数据链路层（传输有地址的帧以及错误检测功能）  
SLIP，CSLIP，PPP，ARP，RARP，MTU
  - 交换机	通过维护一张MAC地址表，只发送给目标MAC地址指向的那一台电脑（以太网）
- 物理层（以二进制数据形式在物理媒体上传输数据）  
TCP/IP 协议：ISO2110，IEEE802，IEEE802.2
  - 集线器	无脑将信号转发给所有MAC地址

#### TCP & UDP 的区别
> TCP是一个面向连接的、可靠的、基于字节流的传输层协议。而UDP是一个面向无连接的传输层协议
1. TCP 提供面向连接的传输，通信前要先建立连接（三次握手机制）；UDP提供无连接的传输，通信前不需要建立连接。
2. TCP 提供可靠的传输（有序，无差错，不丢失，不重复）；UDP提供不可靠的传输。
3. TCP 面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销。
4. TCP 提供拥塞控制和流量控制机制；UDP不提供拥塞控制和流量控制机制。

#### 什么是 http 协议，它在哪一层模型中？
> Hyper Text Transfer Protocol 超文本传输协议，位于 TCP/IP 四层模型当中的应用层。主要是用途客户端和服务端的沟通。

#### http 协议的特点有哪些？
> 
>> pass

#### http 协议不同版本的区别？
> ![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220705103900.png)
- HTTP/1.1 默认使用长连接，可有效减少TCP的三次握手开销。
- HTTP/1.1 支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端接受到100，才开始把请求body发送到服务器。当服务器返回401的时候，客户端可以不用发送请求body了。
- HTTP/2 对 header 压缩；使用多路复用技术，多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
- HTTP/3 是基于 QUIC 传输协议的，具有 HTTP 传输所需的几个特性，例如多路复用、流量控制、每个流的流控制和低延迟连接建立。

#### https 协议中的 s 是什么?
> SSL/TLS 安全套接字层，使得报文能够加密传输。TLS协议，是SSL 3.0协议的升级版

#### https 密钥交换过程是什么？
1. 服务端首先把自己的公钥Key1发给证书颁发机构，向证书颁发机构申请证书。
2. 证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端。
3. 当客户端向服务端请求通信的时候，服务端不再直接返回自己的公钥，而是把自己申请的证书返回给客户端。
4. 客户端收到证书以后，第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以客户端只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。
5. 接下来，客户端按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。验证成功后，客户端就可以放心地再次利用机构公钥，解密出服务端的公钥Key1。
6. 客户端生成自己的对称加密密钥Key2，并且用服务端公钥Key1加密Key2，发送给服务端。
7. 最后，服务端用自己的私钥解开加密，得到对称加密密钥Key2。于是两人开始用Key2进行对称加密的通信。

#### 三次握手怎么理解？
1. 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。
2. 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
3. 客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。

#### 为什么握手不是两次或者四次？
> 两次无法确认客户端的接收能力，四次可以但没必要。

#### 三次握手过程中可以携带数据么？
> 第三次握手的时候，可以携带。前两次握手不能携带数据。

#### Client & Server 同时发送 SYN 会怎么样?
> 同时进行三次握手并处于ESTABLISHED状态

#### 四次挥手怎么理解？
1. 客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.
2. 服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.
3. 服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.
4. 客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.

#### 为什么挥手是四次而不是三次？如果是三次挥手会有什么问题？
> 服务端在接收到FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。所以先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN
> 
>长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。

#### 如何标识唯一标识一个连接？
> TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。

#### TOF 了解嘛？说说它的原理，说说它的优势？
> TCP Fast Open 快速打开
>
> 原理是：在首轮三次握手中服务端不立刻回复 SYN + ACK，而是通过计算得到一个SYN Cookie, 将这个Cookie放到 TCP 报文的 Fast Open选项中，然后才给客户端返回。  
> 后面的三次握手客户端会将之前缓存的 Cookie、SYN 和HTTP请求发送给服务端，服务端验证了 Cookie 的合法性，可以在三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应。 图解  
> ![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220705111833.png)
>
> TFO 的优势在于后面的握手，直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输

#### TCP 报文中时间戳有什么用？
> 计算往返时延 RTT

#### 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？
> 默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。

#### 一个 TCP 连接可以对应几个 HTTP 请求？
> 如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。

#### 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？
> 在 HTTP/1.1 是不可行的。在 HTTP/2 中多个 HTTP 请求可以在同一个 TCP 连接中并行进行

#### 为什么有的时候刷新页面不需要重新建立 SSL 连接？
> TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。

#### 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？
> Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。

#### 到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？
> 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2。  
> 不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是很可能会用到多路复用。
>
> 如果用不了 HTTP2 只能使用 HTTP/1.1 那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，  
> 如果所有的连接都正在发送请求，那其他的请求就只能等等了。

#### 如何理解 TCP 的 keep-alive？
> > pass

#### TCP 的超时重传时间是如何计算的？
> > pass

#### 能不能说一说 TCP 的流量控制？
> > pass

#### 能不能说说 TCP 的拥塞控制？
> > pass

#### 怎么理解 rpc?
> Remote Procedure Call 远程过程调用

#### 已经有 http 服务了为什么还有 rpc 服务？
> 本质的区别就是RPC主要是基于TCP/IP协议的，而HTTP服务主要是基于HTTP协议的，  
> RPC效率更高，而HTTP服务开发迭代会更快。  
> RPC 调用和 HTTP 调用的区别（ [HTTP and RPC](https://github.com/XuYuanzhe/XuYuanzhe/blob/main/documents/HTTP&RPC.md) ）


## 💾 数据库

#### redis 和 memcache 有什么区别？
> redis 支持的数据结构更丰富。memcache 只支持 key-value 的存储；
> redis 原生支持集群，memcache 没有原生的集群模式。

#### redis 和 MySQL 有什么区别？
> redis 是内存数据库，数据保存在内存中，速度快。  
> mysql 是关系型数据库，持久化存储，存放在磁盘里面，功能强大。检索的话，会涉及到一定的 IO，数据访问也就慢。  
> 需要永久存储的数据使用MySQL,比如用户信息,文章等  
> 而临时数据或者经常访问的数据就会使用redis,比如用户的session/排行榜/访问计数/Pub Sub 构建实时消息系统/缓存等

#### redis 的几种数据结构了解吗？
> string、set、zset、hash、list

#### redis 为什么快？除了基于内存操作还有其他原因吗？
> 1.I/O 多路复用，事件处理器处理事件(这个可以理解为注册的一段函数，定义了事件发生的时候应该执行的动作)， 这里分派事件和处理事件其实都是同一个线程；  
> 2.纯内存操作效率高；  
> 3.单线程反而避免了多线程切换。

#### 介绍一下 I/O 多路复用的流程？
> ![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220625232458.png)
> 1.首先接收到客户端的 socket 请求，多路复用器将 socket 转给连接应答处理器；  
> 2.连接应答处理器将 AE_READABLE 事件与命令请求处理器关联(这里是把 socket 事件放入一个队列)；  
> 3.命令请求处理器从 socket 中读到指令，再内存中执行，并将 AE_WRITEABLE 事件与命令回复处理器关联；  
> 4.命令回复处理器将结果返回给 socket，并解除关联。

#### redis 的内存管理机制与gc？
> 定期删除+惰性删除
- 主动过期（定期删除）：默认每 100ms 随机抽取一些设置了过期事件的 key 检查是否过期，如果过期就删除。如果 10w 个 key 都设置了过期时间，全部检查会增高 CPU 负载。
- 被动过期（惰性删除）：key 被访问时，如果发现它已经过期就删除。

> 最大内存淘汰( redis 内存占用太多，就会进行内存淘汰)
- noeviction: 如果内存不足以写入数据， 新写入操作直接报错；  
- allkeys-lru: 内存不足以写入数据，移除最近最少使用的 key(最常用的策略)；  
- allkeys-random: 内存不足随机移除几个 key；  
- volatile-lru: 在设置了过期时间的 key 中，移除最近最少使用；  
- volatile-random: 设置了过期的时间的 key 中，随机移除几个。

#### redis 如何保证高并发场景？
> 读写分离保证高并发(10W+ QPS)：对于缓存来说一般都是支撑高并发读，写请求都是比较少的。master 负责接收写请求，数据同步到 slave 上提供读服务，增加 slave 机器就可以水平扩容。
> ![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220625234713.png)

#### redis 哨兵有了解吗？是干什么的有什么特性？
> 哨兵是 redis 集群架构的一个重要组件，主要提供功能：集群监控、消息通知、故障转移、配置中心
> 哨兵至少三个，保证自己的高可用；  
> 哨兵+主从的部署架构是用来保证 redis 集群高可用的，并非保证数据不丢失；  
> 哨兵(Sentinel)需要通过不断的测试和观察才能保证高可用  

#### 为什么哨兵至少是 3 个，2 个不可以吗？
> 满足 majority 才可以允许故障转移执行。2 个哨兵的 majority 是 2，如果 2 个哨兵都运行着就允许执行故障转移。如果 M1 所在的机器宕机了，那么 s1 哨兵也就挂了，只剩 s2 一个，没有 majorityl 来允许执行故障转移，虽然集群还有一台机器 R1，但是故障转移也不会执行。

#### 用 redis 来实现限制一个api或页面访问的频率，例如单ip或单用户一分钟之内只能访问多少次？
```
在redis中保存一个count值(int)，key为user:$ip，value为该ip访问的次数，第一次设置key的时候，设置expires。
count加1之前，判断是否key是否存在，不存在的话，有两种情况：1、该ip未访问过；2、该ip访问过，但是key已经过期了。那么此时需要再次设置一次expires。如果用户访问的时候，判断count的值是否大于上限，如果低于上限，就处理请求，否则就拒绝处理请求。

# 考虑这种情况，假设只允许用户60秒内访问100次，如果有一个用户在第1秒访问了1次，在第59秒的时候，访问了99次，然后在第61秒的时候，访问了100次。如果按照策略1的情况处理，第1~60秒之间接受了100次，在第61秒接收100次请求，所以62~120这段时间内，不再处理该ip的请求。
# 貌似没问题，但是，细细思考一下，第59秒到61秒之间接受了99+100=199请求，时间间隔只有3秒。那么这样的话，最初的设计就存在问题了。
解决方案：可以使用redis的list（双向队列）数据结构，key就是user:$ip，也就是每一个ip设置一个双向队列，每次请求到达的时候，进行如下判断：
1、如果list中的元素个数少于100个，那么就将请求到达时的时间戳Lpush到list中。
2、如果list中的元素多余100个，那么，就取出Lindex(-1)即最右边，也就是100个请求中最早的那一个请求的时间戳，如果最早的时间戳和当前时间戳相差超过60秒，那么表示第一个请求已经过期了，就将第一个请求出队Rpop。然后将当前时间戳入队Lpush
```

#### 什么是索引？
> 索引是一种单独的，物理的对数据库表中一列或者多列的值进行排序的一种存储结构。  
> 相当于图书的目录，可以根据目录中的页码快速找到需要的内容

#### 什么是联合索引？
> 通过第一个字段的值（部首）在第一级索引中找到对应的第二级索引位置（检字表页码）  
> 然后在第二级索引中根据第二个字段的值（笔画）找到符合条件的数据所在的位置（某个字的真正页码）。

#### 什么是聚集索引、非聚集索引、覆盖索引?
> 像拼音目录这样的索引，数据会根据索引中的顺序进行排列和组织的，这样的索引就被称为聚集索引，而非聚集索引就是其他的一般索引。因为数据只能按照一种规则排序，所以一张表至多有一个聚集索引，但可以有多个非聚集索引  
> https://zhuanlan.zhihu.com/p/476444902

#### 给你ab,ac,abc字段，你是如何加索引的？
> 加abc联合索引和ac联合索引。  
> 这个最左前缀可以是联合索引的最左N个字段。比如组合索引(a,b,c)可以相当于建了(a),(a,b),(a,b,c)三个索引，大大提高了索引复用能力。  
> 最左前缀也可以是字符串索引的最左M个字符。

#### 索引可以创建多少列？
> 16

#### 什么是视图？视图的使用场景有哪些？
> 视图是一种虚拟的表，具有和物理表相同的功能  
> 只暴露部分字段给访问者，所以就建一个虚表，就是视图。  
> 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异

#### 视图的作用是什么？
> 数据库视图隐藏了数据的复杂性。  
> 数据库视图有利于控制用户对表中某些列的访问。  
> 数据库视图使用户查询变得简单。

#### 事务的特性有哪些？
1. 原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。  
2. 一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。  
3. 隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。  
4. 持久性(Durability)：对于任意已交事务，系统必须保证该事务对数据库的改变不被丢失。

#### 主键（primary key）和候选键（candidate key）有什么区别？
> 候选键 - 候选键可以是任何列或可以作为数据库中唯一键的列组合。一张表中可以有多个候选键。每个候选键都可以作为主键。
>
> 主键 - 主键是唯一标识记录的列或列组合。只有一个候选键可以是主键。

#### 主键和唯一键有什么区别?
> 两者都用于强制定义的列的唯一性，但主键会创建聚集索引，而唯一键会在列上创建非聚集索引。主键不允许'NULL'，但唯一键允许它。

#### 数据库怎么优化查询效率？
1. 避免模糊查询，如OR、LIKE等，因为会导致全表扫描；
2. 在常用字段加索引，例如WHERE、JOIN ON和ORDER BY使用到字段上应该加索引
3. 尽量避免全局性的读写操作，例如SELECT * 、Update全部字段

#### 了解数据库优化方案有哪些？
1. 优化索引、SQL 语句、分析慢查询;
2. 设计表的时候严格根据数据库的设计范式来设计数据库;
3. 使用缓存，把经常访问到的数据而且不需要经常变化的 数据放在缓存中，能节约磁盘 IO;
4. 优化硬件;采用 SSD，使用磁盘队列技术 (RAID0,RAID1,RDID5)等;
5. 采用 MySQL 内部自带的表分区技术，把数据分层不同 的文件，能够提高磁盘的读取效率;
6. 垂直分表;把一些不经常读的数据放在一张表里，节约 磁盘 I/O;
7. 主从分离读写;采用主从复制把数据库的读操作和写入操作分离开来;
8. 分库分表分机器(数据量特别大)，主要的的原理就是数据路由;
9. 选择合适的表引擎，参数上的优化;
10. 进行架构级别的缓存，静态化和分布式;
11. 不采用全文索引;
12. 采用更快的存储方式，例如 NoSQL 存储经常访问的数

#### 写一条 SQL 最重要的是什么？
> 命中索引

#### 千万级数据如何自动化并频繁写入 MySQL?
> pandas + sqlalchemy：pandas在sqlalchemy的支持下，可以实现所有常见数据库类型的查询、更新等操作
```python
from sqlalchemy import create_engine
engine = create_engine('mysql+pymysql://root:xuyuanzhe@localhost:3306/test01')
data = pd.read_csv('./tianchi_mobile_recommend_train_user.csv')
data.to_sql('user02',engine,chunksize=100000,index=None)
print('success')
```

#### 如何将数据从一张表复制到另一张表？
```
INSERT INTO table2 (id,uid,changed,status,assign_status) SELECT id,uid,now(),'Pending','Assigned' FROM table1
```

#### 如何在不复制数据的情况下复制表？
```
CREATE TABLE users_bck SELECT * FROM users WHERE 1=0;
```

#### MySQL 的底层数据结构是什么？
> B+树

#### MySQL 的两种引擎是什么？
> InnoDB 和 MyISAM  
InnoDB 支持事务，MyISAM 不支持事务  
InnoDB 支持外键，MyISAM 不支持  
InnoDB 是聚集索引，MyISAM 是非聚集索引

#### MySQL锁有几种?
> pass

#### 死锁是怎么产生的?
> pass

#### char varchar text 有何区别?
> pass

#### 区分 FLOAT 和 DOUBLE？
> 浮点数以八位精度存储在 FLOAT 中，它有四个字节。  
>
>浮点数以 18 位精度存储在 DOUBLE 中，它有 8 个字节。

#### 了解join么，有几种，有何区别? 
> pass

#### NOW() 和 CURRENT_DATE() 有什么区别？
> NOW () 命令用于以小时、分钟和秒显示当前年、月、日。
>
> CURRENT_DATE() 仅显示当前年、月和日期。

#### MySQL 表中允许多少个触发器？
- 插入前
- 插入后
- 更新前
- 更新后
- 删除前
- 删除后

#### 为何，以及如何分区、分表；
> pass

#### 关系型数据库和非关系型数据库？
> pass

#### MongoDB的底层数据结构是什么？
> B树

## 💻 操作系统

#### 怎么理解同步异步？
> 同步和异步关注的是消息通信机制
- 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回；  
而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。  
- 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。  
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

#### 怎么理解阻塞非阻塞?
>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。
- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回；  
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
- 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。  
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关

#### 什么是虚拟内存?
> 虚拟内存则是虚拟出来的、使用磁盘代替内存。memory就是机器的物理内存，读写速度低于cpu一个量级，但是高于磁盘不止一个量级。  
> 所以，程序和数据如果在内存的话，会有非常快的读写速度。内存的断电丢失数据是一个不能把所有数据和程序都保存在内存中对原因。  
> 当内存没有可用的，就必须要把内存中不经常运行的程序给踢出去。但是踢到哪里去，这时候swap就出现了。  
> swap全称为swap place，即交换区，当内存不够的时候，被踢出的进程被暂时存储到交换区。当需要这条被踢出的进程的时候，就从交换区重新加载到内存，否则它不会主动交换到真实内存中。


## 🔱 正则专精

#### 正则匹配 `<.*>` 和 `<.*?>` 分别对 `<h1>title</h1>` 进行正则匹配输出什么?
前者匹配`<h1>title</h1>`，后者匹配 `<h1>`

#### 正则匹配里的 * 和 + 有什么区别?
> 前者匹配零次或多次，后者匹配一次或多次

#### 如何提高正则的可读性？
> 加注释
```python
import re

msg = '我叫xxx，我的密码是:123kingname456,请注意保密。'
pattern = '''
:  # 开始标志
(.*?)  #从开始标志的下一个字符开始的任意字符
,  #遇到英文逗号就停止
'''

re.findall(pattern, msg, flags=re.X)
```

## 🕸️ 爬虫专精

#### 网站如何监测爬虫使用了代理？
1. 根本没有使用代理,`proxies={'http': 'http://IP:port', 'https': 'http://IP:port'}`给https网址设置代理的时候，key是`https`，但值依然是`http://`
2. 代理IP是服务器IP,云服务器IP范围是公开的
3. 代理IP不是高匿代理,区分透明代理、匿名代理、高匿代理
4. 服务器供应商的IP池被污染,垃圾爬虫和你使用了同一家代理
5. 代理不支持HTTP/2,大部分供应商提供的还是HTTP/1.1的代理

#### 在 App 逆向中常见的加密算法有哪些？
1. 消息摘要算法(散列函数、哈希函数) MD5、SHA、MAC
2. 对称加密算法 DES、3DES、AES
3. 非对称加密算法 RSA
4. 数字签名算法 MD5withRSA、SHA1withRSA、SHA256withRSA

## 🐍 Python 语言特性

#### 面向对象的特点？
> 封装、继承和多态

#### python 一切皆对象怎么理解？
> type 类实例化了 object ，type 类由继承自 object，这不矛盾。无论是 type，还是 object，它们即是对象，也是类，所以既拥有对象的特性，也拥有类的特性。  
> type 掌管了对象的特性，object 掌管了类的特性，所以两者相互依存。我们 用一幅图来说明，如下图所示，虚线表示对象实例化生成关系，实线表示类的继承关系。  
> 所有类都拥有对象的特信息，所以都由type实例化生成，所有对象都拥有类的特性，所以都继承自 object。  
> ![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220604170940.png)

#### 什么是类？
> 类是模板，而实例则是根据类创建的对象。  
> 使用类的对象，我们可以访问类的所有成员，并对其进行操作。

#### 什么是元类？
> 实例对象是由类来创建，类是由元类来创建的。python的类都是由 `type` 类继承的，可以想象为元类是一个类的父类。在Django中多用元类创建语法糖。  
> [Python MetaClass Notes](https://github.com/XuYuanzhe/XuYuanzhe/blob/main/documents/PythonMetaClass.md)

#### Python 的装饰器怎么理解？内部实现原理？
> 装饰器本质上是一个Python函数，是闭包的一种实现, 它的作用是让其他函数在不需要做任何代码变动的前提下增加额外功能。  
> 使用装饰器的时候, 解析器把被装饰的函数作为参数传递给装饰器, 然后再返回一个函数对象, 装饰器内部实现需要额外增加的功能和被装饰函数的功能,虽然被装饰函数的调用方法没有改变, 但实际上已经不是原来函数, 而变成了装饰器返回的函数对象  
> 它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。  
 
#### 什么是面向切面编程AOP?  
> 在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。  

#### 手写一个普通装饰器，一个带参装饰器？
```python
import functools

# 普通装饰器
def decorator(fn):
  context = 1
  
  @functools.wraps(fn)
  def wrapper(*args, **kwargs):
    print("context", context)
    return fn(*args, **kwargs)
  return wrapper


@decorator
def func():
  print("I am target")

func()


#带参数的装饰器
def decorator_out(context):
    def decorator(fn):
        @functools.wraps(fn)
        def wrapper(*args, **kwargs):
            print("context", context)
            return fn(*args, **kwargs)
        return wrapper
    return decorator


@decorator_out(3)
def test(*args, **kwargs):
    print(1)

test()
```

#### @staticmethod & @classmethod 有何区别？
> Python 有 3 个方法,静态方法,类方法,实例方法
```python
def foo(x):
    print("executing foo(%s)" % x)


class A(object):
    # 实例方法
    def foo(self, x):
        print("executing foo(%s,%s)" % (self, x))

    # 类方法
    @classmethod
    def class_foo(cls,x):
        print("executing class_foo(%s,%s)" % (cls, x))

    # 静态方法
    @staticmethod
    def static_foo(x):
        print("executing static_foo(%s)" % x)


a = A()
```

| \\      | 实例方法    | 类方法            | 静态方法            |
| :------ | :-------   | :------------- | :-------------- |
| a = A() | a.foo(x)   | a.class_foo(x) | a.static_foo(x) |
| A       | 不可用      | A.class_foo(x) | A.static_foo(x) |


#### 解释一下实例方法中的 self
> 在类里每次定义方法的时候都需要绑定实例,也就是foo(self, x)  
> 因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的 a.foo(x) 但其实是foo(a, x)

#### 魔术方法的双下划线意义何在？
> 只是一种约定,Python 内部的名字,用来区别其他用户自定义的命名,以防冲突

#### 将列表生成式中 [] 改成 () 之后数据结构是否改变?
> 是，从列表变为生成器

#### iterator & generator
> 可迭代的对象的意思是就是说这个实体是可迭代的，例如字符、列表、元组、字典、迭代器等等，可以用for ... in进行循环，可以使用for循环迭代的标志是内部实现了`__iter__`方法。  
> 在 py2 中 range 和 xrange 前者返回list后者返回的是一个生成器，不会一下子开辟出所有的内存空间，边循环，边计算。

#### new & init
- __new__是一个静态方法,而__init__是一个实例方法.
- __new__方法会返回一个创建的实例,而__init__什么都不返回.
- 只有在__new__返回一个cls的实例时后面的__init__才能被调用.
- 当创建一个新实例时调用__new__,初始化一个实例时用__init__.

#### 手写一个单例模式？说说理解
```python
class Singleton(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kwargs)
        return cls._instance


class MyClass(Singleton):
    a = 1
```
> 通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。

#### enter & exit
> with方法帮助实现了一个 __enter__ 和 __exit__ 的方法。读取和退出的时候自动调用，在操作文件或网络的异步操作的时候很有用。

#### 打开一个超大的 JSON 文件用 with 方法好吗？为什么不好？
> 不好，将整个JSON文件直接加载到内存中是一种内存浪费。
> 每个字符串都有固定的开销，如果字符串可以表示为 ASCII，则每个字符只使用一个字节的内存。如果字符串使用更多扩展字符，则每个字符可能使用4个字节

#### 如何查看一个对象的内存？ 
> sys.getsizeof()

#### 怎么做更好？
> 流解析，或者说是惰性解析、迭代解析或分块处理，比如使用 `ijson` `pandas` `SQLite`

#### Python 代码是怎样执行的?
> 首先，解释器读取Python代码并检查是否有语法或格式错误。  
> 如果发现错误，则暂停执行。如果没有发现错误，则解释器会将Python代码转换为等效形式或字节代码。  
> 然后将字节码发送到Python虚拟机(PVM)，这里Python代码将被执行，如果发现任何错误，则暂停执行，否则结果将显示在输出窗口中。

#### Python 中可变对象和不可变对象是什么？  
> 所谓可变对象是指，对象的内容是可变的。而不可变的对象则相反，表示其内容不可变。  
> 不可变对象(int，string，float，tuple)可理解为C中，该参数为值传递  
> 可变对象(list，dict)可理解为C中，该参数为指针传递

#### python 内置有哪些数值类型？
- 整型（int）
- 浮点数（float）
- 布尔型（bool）
- 复数（complex）

#### python 内置有哪些数据结构?
- List 列表：有序、可变、可迭代。
- Tuple 元组：有序、不可变、可迭代。
- Dict 字典：可变
- Set 集合

#### List 拓展有哪些方法有什么区别？
- append：在列表末尾添加新元素。
- insert：在列表的特定位置添加元素。
- extend：通过添加新列表来扩展列表。

#### Dict 的底层使用什么实现的，查找的时间复杂度是多少？为什么？
> dict 的底层是 hashmap 实现的, 查找的时间复杂度为O(1),

#### 双向字典了解嘛，通过 value 找到 key？
> Bi-Dictionary 库可以做到  
> https://mp.weixin.qq.com/s/VOcnZnJ2PWO_smxkK3h7rw

#### Python 已经有 list 结构为什么还要有 tuple?
> 1.更省内存。Tuple 在内存和处理速度上都优于 List
> 2.可哈希。因此 Tuple 可以内嵌在 Dict 里面
> 3.线程安全。因为 Tuple是只读的, 这就使得它天生能避免读写冲突和写写冲突，在多线程时候可以大胆放心的使用, python底层中也用了很多tuple.

#### python 是如何管理内存的？
> 所有的 Python 对象和数据结构都位于一个私有堆中。私用堆的分配由 Python 内存管理器负责。  
> Python 还内置了一个的垃圾收集器，可以回收未使用的内存并释放内存，使其可用于 headspace。

#### python 的垃圾回收机制是怎样的？
> Python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略
- 引用计数  
当一个对象有新的引用时，对象的引用计数+1；当一个对象的引用被销毁时，对象的引用计数-1；
- 分代回收  
循环引用导致引用计数不能清零会造成内存泄漏；函数的参数适用了可变变量 `list` `dict`  而默认不是这种可变变量
- 标记-清除

#### 如何避免循环引用?
> 如果循环引用中，两个对象都定义了 `__del__` 方法，gc模块不会销毁这两个不可达对象，因为gc模块不知道应该先调用哪个对象的 `__del__` 方法    
> 例如，两个对象a和b，如果先销毁a，则在销毁b时，会调用b的 `__del__` 方法，该方法中很可能使用了a，这时会造成异常，  
> 所以为了安全起见，gc模块会把对象放到 gc.garbage 中，并把它们称为 uncollectable。很明显，这种情况会造成内存泄漏，  
> 要解决的话，只能显式调用其中某个对象的 `__del__` 方法来打破僵局。

#### 解释一下 GIL 锁
> 一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢

#### 什么是io密集型？什么是cpu密集型？
> 网络请求，读写这种属于前者，数学计算属于后者。

#### 解释一下进程、线程、协程
- 进程：是CPU对程序的一次执行过程、一次执行任务。各个进程有自己的内存空间、数据栈等。
- 线程：是进程中执行运算的最小单位，是进程中的一个实体。
- 协程：比线程更小的执行单元，又称微线程，在单线程上执行多个任务，自带CPU上下文。想要使用协程，那么我们的任务必须有等待。  
当我们要完成的任务有耗时任务，属于IO密集型任务时，我们使用协程来执行任务会节省很多的资源。

#### python 怎么实现多线程？
> python使用`threading`实现多线程，使用`gevent + asyncio`实现携程。在Python的进程里只有一个GIL。一个线程需要执行任务，必须获取GIL。  
- 好处：直接杜绝了多个线程访问内存空间的安全问题。  
- 坏处：Python的多线程不是真正多线程，不能充分利用多核CPU的资源。

#### multiprocessing 有了解嘛？和 asyncio 有什么区别？
> multiprocessing是一个允许程序员充分利用给定机器上的多个处理器，且支持使用 API 生产进程的包。  
> ![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220705103126.png)

#### python 的多线程不是真正的多线程，为什么还要用？
> 多线程有两个好处：CPU并行，IO并行。  
> Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。  
> 多核多线程比单核多线程更差，原因是单核下的多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，  
> 但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低

#### 如何最大性能执行 python
> 更推荐多进程而不是多线程

#### 为什么python代码执行缓慢？
> ![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220705141729.png)    
> 因为它是一种解释型语言。它的代码在运行时进行解释，而不是编译为本地语言。

#### 如何提高执行速度？
> 可以使用CPython、Numba，或者我们也可以对代码进行一些修改。首先看瓶颈在哪里，如果在CPU计算比较重可以用c实现一下；  
> 如果是跟code关系不大主要是网络数据库这一块，就要看sql语法和携程调用有没有充分使用；`line_profiler` 在code里写上可以帮助分析这一块的性能；  
> `cProfiler` 帮助分析整体性能；火焰图   

#### python 的第三方库 Pipe 有用过吗？
> https://mp.weixin.qq.com/s/eoctrMLuxPNd8bWJvenM6Q

#### python 内置的弱引用 weakref 了解吗？
> https://mp.weixin.qq.com/s/kS4QEt8rVfuuGx5CX1_Kew

#### 虚拟环境工具 poetry 了解吗？
> https://mp.weixin.qq.com/s/LgdtP7ndSa-ZwgeMxTtwLQ

#### Python 实现定时任务有哪些方案？
> https://mp.weixin.qq.com/s/R711eavHKBbvPlZXtUZ8Dg

## 🛠️ 应用框架

#### Django 和 Tornado 的关系、差别在哪里？
> pass

#### MVC / MTV；
> pass

#### 缓存怎么用；
> pass

#### 中间件是干嘛的；
> pass

#### CSRF是什么，django是如何避免的；XSS呢；
> pass

#### 如果你来设计login，简单的说一下思路；
> pass

#### session和cookie的联系与区别；session为什么说是安全的；
> pass

#### uWSGI和Nginx的作用；
> pass

#### scrapy 框架工作流程

![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20210922172935.png)

## 🦳 白帽子

https://mp.weixin.qq.com/s/0rATDy-rjL9SVR3doR7MMg