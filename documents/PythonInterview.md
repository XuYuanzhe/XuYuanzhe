# Python Interview 面试相关

### **Python代码是如何执行的？**

首先，解释器读取Python代码并检查是否有语法或格式错误。

如果发现错误，则暂停执行。如果没有发现错误，则解释器会将Python代码转换为等效形式或字节代码。

然后将字节码发送到Python虚拟机(PVM)，这里Python代码将被执行，如果发现任何错误，则暂停执行，否则结果将显示在输出窗口中。

### **解释Python的内置数据结构？**
Python中主要有四种类型的数据结构。 

列表：列表是从整数到字符串甚至另一个列表的异构数据项的集合。列表是可变的。列表完成了其他语言中大多数集合数据结构的工作。列表在[ ]方括号中定义。
例如：a = [1,2,3,4]

集合：集合是唯一元素的无序集合。集合运算如联合|，交集&和差异，可以应用于集合。{}用于表示一个集合。
例如：a = {1,2,3,4}

元组：Python元组的工作方式与Python列表完全相同，只是它们是不可变的。()用于定义元组。
例如：a =（1,2,3,4）

字典：字典是键值对的集合。它类似于其他语言中的hash map。在字典里，键是唯一且不可变的对象。
例如：a = {'number'：[1,2,3,4]}


### **Python中append，insert和extend的区别?**

append：在列表末尾添加新元素。
insert：在列表的特定位置添加元素。
extend：通过添加新列表来扩展列表。


### **解释\*args和\*\*kwargs？**

*args，是当我们不确定要传递给函数参数的数量时使用的。
**kwargs，是当我们想将字典作为参数传递给函数时使用的。



### **类和对象有什么区别？**

类(Class)被视为对象的蓝图。类中的第一行字符串称为doc字符串，包含该类的简短描述。

在Python中，使用class关键字可以创建了一个类。一个类包含变量和成员组合，称为类成员。

对象(Object)是真实存在的实体。在Python中为类创建一个对象，我们可以使用obj = CLASS_NAME()
例如：obj = num()

使用类的对象，我们可以访问类的所有成员，并对其进行操作。


### **你对Python类中的self有什么了解？**

self表示类的实例。

通过使用self关键字，我们可以在Python中访问类的属性和方法。

注意，在类的函数当中，必须使用self，因为类中没有用于声明变量的显式语法。


# **打印斐波那契数列的前十项**

```python
fibo = [0,1]
[fibo.append(fibo[-2]+fibo[-1]) for i in range(8)]

fibo
> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

```

#### **python的内存管理机制，如何避免循环引用的问题**

Python内存由Python的私有headspace管理。

所有的Python对象和数据结构都位于一个私有堆中。私用堆的分配由Python内存管理器负责。

Python还内置了一个的垃圾收集器，可以回收未使用的内存并释放内存，使其可用于headspace。

引用计数；分代回收；标记-清除

https://zhuanlan.zhihu.com/p/124290355

当一个对象有新的引用时，对象的引用计数+1；当一个对象的引用被销毁时，对象的引用计数-1；

循环引用导致引用计数不能清零会造成内存泄漏；函数的参数适用了可变变量 `list` `dict`  而默认不是这种可变变量

如果循环引用中，两个对象都定义了*__del__*方法，gc模块不会销毁这两个不可达对象，因为gc模块不知道应该先调用哪个对象的*__del__*方法（例如，两个对象a和b，如果先销毁a，则在销毁b时，会调用b的*__del__*方法，该方法中很可能使用了a，这时会造成异常），所以为了安全起见，gc模块会把对象放到*gc.garbage*中，并把它们称为uncollectable。很明显，这种情况会造成内存泄漏，要解决的话，只能显式调用其中某个对象的*__del__*方法来打破僵局。


#### **在python中随机化列表中的元素**

```
numpy.random.randint(k, size=n)
numpy.random.shuffle(seq)
random.sample(seq, k)
random.choice(seq)
```


#### **python iterator generator**

可迭代的对象的意思是就是说这个实体是可迭代的，例如字符、列表、元组、字典、迭代器等等，可以用for ... in进行循环，可以使用for循环迭代的标志是内部实现了`__iter__`方法。

可迭代对象仅含有`__iter__`的内部方法，你可以通过封装next()方法（python3中为`__next__()`）来将其做成一个迭代器，以生成器（generator，特殊的函数类型的迭代器）为例，你可以通过yield关键字来做一个迭代器，只不过名字被叫做generator，yield可以看做就是为对象添加了`__iter__`方法和指示下一次迭代的`next()/__next__()`方法。

使用isinstance(实体名,Iterable)可判断是否为可迭代对象

在 py2中 range 和 xrange 前者返回list后者返回的是一个生成器，不会一下子开辟出所有的内存空间，生成一个开一个。



#### **with 语法的实现方式**

帮助实现了一个`__enter__` 和 `__exit__` 的方法。读取和退出的时候自动调用，在操作文件或网络的异步操作的时候很有用。


#### **python 类里面的mixin的用法**

相当于一种多重继承，子类拥有所有父类的变量、成员函数。


#### **如何创建一个python的元类**

实例对象是由类来创建，类是由元类来创建的。

python的类都是由 `type` 类继承的，可以想象为元类是一个类的父类。

在Django中多用元类创建语法糖。


#### **python的线程进程和携程协程**

进程：是CPU对程序的一次**执行过程**、一次**执行任务**。各个进程有自己的内存空间、数据栈等。

线程：是进程中执行运算的最小单位，是进程中的一个**实体**。

协程：比线程更小的执行单元，又称微线程，在单线程上执行多个任务，自带CPU上下文。想要使用协程，那么我们的任务必须有等待。当我们要完成的任务有耗时任务，属于IO密集型任务时，我们使用协程来执行任务会节省很多的资源。

python使用`threading`实现多线程，使用`gevent + asyncio`实现携程。在Python的进程里只有一个GIL。一个线程需要执行任务，必须获取GIL。

* 好处：直接杜绝了多个线程访问内存空间的安全问题。

* 坏处：Python的多线程不是真正多线程，不能充分利用多核CPU的资源。


#### **python性能调优**
Python代码执行缓慢的原因，是因为它是一种解释型语言。它的代码在运行时进行解释，而不是编译为本地语言。

为了提高Python代码的速度，我们可以使用CPython、Numba，或者我们也可以对代码进行一些修改。

1. 减少内存占用。
2. 使用内置函数和库。
3. 将计算移到循环外。
4. 保持小的代码库。
5. 避免不必要的循环

首先看瓶颈在哪里，如果在CPU计算比较重可以用c实现一下；如果是跟code关系不大主要是网络数据库这一块，就要看sql语法和携程调用有没有充分使用；`line_profiler` 在code里写上可以帮助分析这一块的性能； `cProfiler` 帮助分析整体性能；火焰图 


#### **同步异步阻塞非阻塞**

- 同步和异步关注的是**消息通信机制**。所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该调用就不返回；而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果**。

  你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
  而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

- 阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**。阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回；非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

  你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
  在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关

  

#### **http 1.0 / 1.1 / 2.0**

首先http协议是一种构建在TCP协议之上的应用层协议,主要是用途客户端和服务端的沟通.

- HTTP1.1默认使用长连接，可有效减少TCP的三次握手开销。
- HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。
- HTTP2.0对header压缩；使用多路复用技术，多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。



#### **TCP/IP**

- 应用层

- 表示层

- 会话层

- 传输层

  |            | TCP                                              | UDP                                        |
  | ---------- | ------------------------------------------------ | ------------------------------------------ |
  | 可靠性     | 可靠                                             | 不可靠                                     |
  | 连接性     | 面向连接                                         | 无连接                                     |
  | 效率       | 传输效率低                                       | 传输效率高                                 |
  | 双工性     | 全双工                                           | 一对一、一对多、多对一、多对多             |
  | 传输速度   | 慢                                               | 快                                         |
  | 应用场景   | 对效率要求低，对准确性要求高或者要求有链接的场景 | 对效率要求高，对准确性要求低的场景         |
  | 应用层协议 | SMTP电子邮件/HTTP万维网/FTP文件传输              | DNS域名转换/TFTP文件传输/NFS远程文件服务器 |

  

- 网络层				

  - 路由器	拥有独立MAC帮助转发，本身没有传输包的功能实际传输是委托给数据链路层的

  - IP协议是不可靠协议，数据处理被认为是上层协议要做的事

  - 32位IP地址分为网络位和地址位，这样可以减少路由表记录的数目

    - A类IP地址：0.0.0.0 ～1 27.0.0.0
    - B类IP地址：128.0.0.1 ～ 191.255.0.0
    - C类IP地址：192.168.0.0 ～ 239.255.255.0

    

- 数据链路层		
  - 交换机	通过维护一张MAC地址表，只发送给目标MAC地址指向的那一台电脑（以太网）

- 物理层				
  - 集线器	无脑将信号转发给所有MAC地址

#### **swap 虚拟内存**

虚拟内存则是虚拟出来的、使用磁盘代替内存。memory就是机器的物理内存，读写速度低于cpu一个量级，但是高于磁盘不止一个量级。所以，程序和数据如果在内存的话，会有非常快的读写速度。内存的断电丢失数据是一个不能把所有数据和程序都保存在内存中对原因。当内存没有可用的，就必须要把内存中不经常运行的程序给踢出去。但是踢到哪里去，这时候swap就出现了。**swap全称为swap place，即交换区**，当内存不够的时候，被踢出的进程被暂时存储到交换区。当需要这条被踢出的进程的时候，就从交换区重新加载到内存，否则它不会主动交换到真实内存中。


#### **数据结构**