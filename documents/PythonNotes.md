# Python Notes

## **二叉树、平衡二叉树、树、B+树**
1.二叉查找树的时间复杂度是多少？  
- O(logn) 应该是平衡状态下，节点分布失衡会退化到 O(n) 在一条链上  

2.O(logn)中的log是以什么为底？  
- 以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数  
以2为底10的对数是一个常数，这里忽略常数项系数  
log 以 i 为底 n 的对数等于 log 以 j 为底 n 的对数，所以忽略了 i，直接说是logn

3.这里的n是指？
- n 个节点

4.二叉查找树和二分法哪个速度更快？
- 两者时间复杂度都是 log2(n)  
两者明显的区别是二分查找速度快删除和插入困难，对于建立的二叉树索引来说，他的插入和删除是相对较快的。

5.为什么会出现这两者的差别？
- 从空间性能，顺序存储会对空间资源做到百分之百的利用，而链式存储对对空间的利用不是百分之百，因为存储了指针，不是真正的数据；  
从时间性能上来讲读取速度的话顺序存储更优，插入和删除操作链式存储更优，链式存储只需要移动指针，不需要移动元素。

6.什么时候采用二分什么时候采用二叉索引？
- 如果数据是不进行频繁变化且是有序，而且查询相对较多的情况下采用二分查找；  
数据是频繁变化的考虑到后面的数据扩容的情况下，考虑采用二叉索引的方式，但是会有一点空间资源的牺牲。

7.二叉树的遍历方式有哪些？实现一下代码？
- 前、中、后序遍历
```python
# 二叉树中序遍历的递归 value  left  right
def inorder(root):
    if not root:
        return 
    inorder(root.left)
    print(root.val)
    inorder(root.right)
    
# 二叉树先序遍历的递归 left  value  right
def preorder(root):
    if not root:
        return 
    print(root.val)
    preorder(root.left)
    preorder(root.right)
   
# 二叉树后序遍历的递归 left  right value
def postorder(root):
    if not root:
        return 
    postorder(root.left)
    postorder(root.right)
    print(root.val)
```
8.怎么判断二叉树平衡？
- 左右两个子树的高度差的绝对值均不超过 1

9.什么是平衡二叉树？
- 又叫AVL树，是一种特殊的二叉查找树，可以自动调节平衡。  
AVL树维持着严格的平衡，任意节点两颗子树的高度差都不超过1。  
优点是保证了查询效率，缺点是维持平衡成本较高，适合查询较多的场景。

10.什么是红黑树？
- 是另一种可以自动调整平衡的二叉查找树。优点是降低了维持平衡的成本，缺点是查询效率底，适合频繁插入删除的场景。

11.什么是B树和B+树？
- B树解决了从磁盘海量数据中查询的需求，有效减少了磁盘I/O的频次。  
B+树是B树的升级，叶子结点包括全量数据，并使用双向指针连接相邻节点，为范围查询提供了便利。

## **python 类和对象**
1.什么是面向对象？
- 封装、继承和多态

2.python 一切皆对象怎么理解？
- type类实例化了object，type类由继承自object，这不矛盾。无论是type，还是object，它们即是对象，也是类，所以既拥有对象的特性，也拥有类的特性。  
刚说过，type掌管了对象的特性，object掌管了类的特性，所以两者相互依存。我们 用一幅图来说明，如下图所示，虚线表示对象实例化生成关系，实线表示类的继承关系。  
所有类都拥有对象的特信息，所以都由type实例化生成，所有对象都拥有类的特性，所以都继承自object。  
![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20220604170940.png)

3.什么是类？
- 类是模板，而实例则是根据类创建的对象。  
使用类的对象，我们可以访问类的所有成员，并对其进行操作。

4.什么是元类？
- 实例对象是由类来创建，类是由元类来创建的。python的类都是由 `type` 类继承的，可以想象为元类是一个类的父类。在Django中多用元类创建语法糖。  
- [Python MetaClass Notes](https://github.com/XuYuanzhe/XuYuanzhe/blob/main/documents/PythonMetaClass.md)

## **Python 魔术方法**
1.iterator generator
- 可迭代的对象的意思是就是说这个实体是可迭代的，例如字符、列表、元组、字典、迭代器等等，可以用for ... in进行循环，可以使用for循环迭代的标志是内部实现了`__iter__`方法。  
- 在 py2中 range 和 xrange 前者返回list后者返回的是一个生成器，不会一下子开辟出所有的内存空间，生成一个开一个。

2.new init
- new先被调用，init是初始化调用

3.enter exit
- with方法帮助实现了一个 __enter__ 和 __exit__ 的方法。读取和退出的时候自动调用，在操作文件或网络的异步操作的时候很有用。

## **Python 代码是如何执行的？**
- 首先，解释器读取Python代码并检查是否有语法或格式错误。  
如果发现错误，则暂停执行。如果没有发现错误，则解释器会将Python代码转换为等效形式或字节代码。  
然后将字节码发送到Python虚拟机(PVM)，这里Python代码将被执行，如果发现任何错误，则暂停执行，否则结果将显示在输出窗口中。

## **Python 内置的数据结构和数据类型**
1.python 内置有哪些数值类型？
- 整型（int）
- 浮点数（float）
- 布尔型（bool）
- 复数（complex）

2.python 内置有哪些数据结构
- List 列表：有序、可变、可迭代。
- Tuple 元组：有序、不可变、可迭代。
- Dict 字典：可变
- Set 集合

3.List拓展有哪些方法有什么区别？
- append：在列表末尾添加新元素。
- insert：在列表的特定位置添加元素。
- extend：通过添加新列表来扩展列表。

4.Dict的底层使用什么实现的，查找的时间复杂度是多少？为什么？
- dict的底层是 hashmap 实现的, 查找的时间复杂度为O(1),

5.Python 可变对象和不可变对象是什么？  
- 所谓可变对象是指，对象的内容是可变的。而不可变的对象则相反，表示其内容不可变。  
不可变对象(int，string，float，tuple)可理解为C中，该参数为值传递  
可变对象(list，dict)可理解为C中，该参数为指针传递

6.Python 已经有 list 结构为什么还要有 tuple?
- 更省内存。Tuple 在内存和处理速度上都优于 List
- 可哈希。因此 Tuple 可以内嵌在 Dict 里面
- 线程安全。因为 Tuple是只读的, 这就使得它天生能避免读写冲突和写写冲突，在多线程时候可以大胆放心的使用, python底层中也用了很多tuple.

## **python 内存管理**
1.python是如何管理内存的？
- 所有的Python对象和数据结构都位于一个私有堆中。私用堆的分配由Python内存管理器负责。  
Python还内置了一个的垃圾收集器，可以回收未使用的内存并释放内存，使其可用于headspace。

2.如何避免循环引用?
- https://zhuanlan.zhihu.com/p/124290355  
- 引用计数  
当一个对象有新的引用时，对象的引用计数+1；当一个对象的引用被销毁时，对象的引用计数-1；
- 分代回收  
循环引用导致引用计数不能清零会造成内存泄漏；函数的参数适用了可变变量 `list` `dict`  而默认不是这种可变变量
- 标记-清除  
如果循环引用中，两个对象都定义了 `__del__` 方法，gc模块不会销毁这两个不可达对象，因为gc模块不知道应该先调用哪个对象的 `__del__` 方法  
例如，两个对象a和b，如果先销毁a，则在销毁b时，会调用b的 `__del__` 方法，该方法中很可能使用了a，这时会造成异常，  
所以为了安全起见，gc模块会把对象放到gc.garbage 中，并把它们称为uncollectable。很明显，这种情况会造成内存泄漏，  
要解决的话，只能显式调用其中某个对象的 `__del__` 方法来打破僵局。

## **python 线程进程和携程协程**
1.解释一下进程、线程、协程
- 进程：是CPU对程序的一次**执行过程**、一次**执行任务**。各个进程有自己的内存空间、数据栈等。
- 线程：是进程中执行运算的最小单位，是进程中的一个**实体**。
- 协程：比线程更小的执行单元，又称微线程，在单线程上执行多个任务，自带CPU上下文。想要使用协程，那么我们的任务必须有等待。  
当我们要完成的任务有耗时任务，属于IO密集型任务时，我们使用协程来执行任务会节省很多的资源。

2.python怎么实现多线程？
- python使用`threading`实现多线程，使用`gevent + asyncio`实现携程。在Python的进程里只有一个GIL。一个线程需要执行任务，必须获取GIL。  
好处：直接杜绝了多个线程访问内存空间的安全问题。  
坏处：Python的多线程不是真正多线程，不能充分利用多核CPU的资源。

3.python的多线程不是真正的多线程，为什么还要用？
-多线程有两个好处：CPU并行，IO并行。  
Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。  
多核多线程比单核多线程更差，原因是单核下的多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，  
但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低)

4.如何最大性能执行python
- 更推荐多进程而不是多线程

## **python 性能调优**
1.为什么python代码执行缓慢？
- 因为它是一种解释型语言。它的代码在运行时进行解释，而不是编译为本地语言。

2.如何提高执行速度？
- 可以使用CPython、Numba，或者我们也可以对代码进行一些修改。首先看瓶颈在哪里，如果在CPU计算比较重可以用c实现一下；  
如果是跟code关系不大主要是网络数据库这一块，就要看sql语法和携程调用有没有充分使用；`line_profiler` 在code里写上可以帮助分析这一块的性能；  
`cProfiler` 帮助分析整体性能；火焰图   

## **Django DRF Flask Tornado**
pass

## **Scrapy PySpider**
1.scrapy框架

![](https://raw.githubusercontent.com/XuYuanzhe/Figurebed/master/img/20210922172935.png)

## **OSI 七层模型和 TCP/IP 四层模型**

1.为什么有 TCP/IP 四层模型？  
- OSI 七层协议体系结构的概念清楚，理论也比较完整，但它既复杂又不实用 

2.对 TCP/IP 四层模型的理解？
- 应用层（数据段）
- 传输层（数据包）
- 网络层（数据帧）
- 数据链路层（比特流）

3.对 OSI 七层模型的理解？
- 应用层（文件传输，电子邮件，文件服务，虚拟终端）  
TCP/IP 协议：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
- 表示层（数据格式化，代码转换，数据加密）  
TCP/IP 协议：没有协议
- 会话层（解除或建立与别的接点的联系）  
TCP/IP 协议：没有协议
- 传输层（提供端对端的接口）  
TCP/IP 协议：TCP，UDP

  |            | TCP                                              | UDP                                        |
  | ---------- | ------------------------------------------------ | ------------------------------------------ |
  | 可靠性     | 可靠                                             | 不可靠                                     |
  | 连接性     | 面向连接                                         | 无连接                                     |
  | 效率       | 传输效率低                                       | 传输效率高                                 |
  | 双工性     | 全双工                                           | 一对一、一对多、多对一、多对多             |
  | 传输速度   | 慢                                               | 快                                         |
  | 应用场景   | 对效率要求低，对准确性要求高或者要求有链接的场景 | 对效率要求高，对准确性要求低的场景         |
  | 应用层协议 | SMTP电子邮件/HTTP万维网/FTP文件传输              | DNS域名转换/TFTP文件传输/NFS远程文件服务器 |

- 网络层（为数据包选择路由）  
TCP/IP 协议：IP，ICMP，RIP，OSPF，BGP，IGMP
  - 路由器	拥有独立MAC帮助转发，本身没有传输包的功能实际传输是委托给数据链路层的
  - IP协议是不可靠协议，数据处理被认为是上层协议要做的事
  - 32位IP地址分为网络位和地址位，这样可以减少路由表记录的数目
    - A类IP地址：0.0.0.0 ～ 1 27.0.0.0
    - B类IP地址：128.0.0.1 ～ 191.255.0.0
    - C类IP地址：192.168.0.0 ～ 239.255.255.0
- 数据链路层（传输有地址的帧以及错误检测功能）  
SLIP，CSLIP，PPP，ARP，RARP，MTU
  - 交换机	通过维护一张MAC地址表，只发送给目标MAC地址指向的那一台电脑（以太网）
- 物理层（以二进制数据形式在物理媒体上传输数据）  
TCP/IP 协议：ISO2110，IEEE802，IEEE802.2
  - 集线器	无脑将信号转发给所有MAC地址

## **http 1.0 / 1.1 / 2.0 https**
1.http 协议在哪一层模型中？
- 首先http协议是一种构建在TCP协议之上的应用层协议,主要是用途客户端和服务端的沟通.

2.http 协议不同版本的区别？
- HTTP1.1默认使用长连接，可有效减少TCP的三次握手开销。
- HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。
- HTTP2.0对header压缩；使用多路复用技术，多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。

3.https 协议中的 s 是什么?
- SSL/TLS 安全套接字层，使得报文能够加密传输。

## **rpc & http**

RPC 调用和 HTTP 调用的区别（ [HTTP and RPC](https://github.com/XuYuanzhe/XuYuanzhe/blob/main/documents/HTTP&RPC.md) ）

## **redis**
1.redis的几种数据结构了解吗？
- string、set、zset、hash、list

2.redis为什么快？除了基于内存操作还有其他原因吗？
- IO多路复用

3.redis的内存管理机制与gc？
- 被动过期（惰性删除）：key被访问时，如果发现它已经过期就删除。
- 主动过期（定期删除）：周期性地从过期字典中选择一部分失效的主键删除。

4.用redis来实现限制一个api或页面访问的频率，例如单ip或单用户一分钟之内只能访问多少次？
```
在redis中保存一个count值(int)，key为user:$ip，value为该ip访问的次数，第一次设置key的时候，设置expires。
count加1之前，判断是否key是否存在，不存在的话，有两种情况：1、该ip未访问过；2、该ip访问过，但是key已经过期了。那么此时需要再次设置一次expires。如果用户访问的时候，判断count的值是否大于上限，如果低于上限，就处理请求，否则就拒绝处理请求。

# 考虑这种情况，假设只允许用户60秒内访问100次，如果有一个用户在第1秒访问了1次，在第59秒的时候，访问了99次，然后在第61秒的时候，访问了100次。如果按照策略1的情况处理，第1~60秒之间接受了100次，在第61秒接收100次请求，所以62~120这段时间内，不再处理该ip的请求。
# 貌似没问题，但是，细细思考一下，第59秒到61秒之间接受了99+100=199请求，时间间隔只有3秒。那么这样的话，最初的设计就存在问题了。
解决方案：可以使用redis的list（双向队列）数据结构，key就是user:$ip，也就是每一个ip设置一个双向队列，每次请求到达的时候，进行如下判断：
1、如果list中的元素个数少于100个，那么就将请求到达时的时间戳Lpush到list中。
2、如果list中的元素多余100个，那么，就取出Lindex(-1)即最右边，也就是100个请求中最早的那一个请求的时间戳，如果最早的时间戳和当前时间戳相差超过60秒，那么表示第一个请求已经过期了，就将第一个请求出队Rpop。然后将当前时间戳入队Lpush
```

## **数据库**
1.写一条 SQL 最重要的是什么？
- 命中索引

2.什么是索引？
- 索引是一种单独的，物理的对数据库表中一列或者多列的值进行排序的一种存储结构。  
相当于图书的目录，可以根据目录中的页码快速找到需要的内容

3.关系型数据库和非关系型数据库？

4.MySQL 的底层数据结构是什么？
- B+树

5.MySQL 的两种引擎是什么？
- InnoDB 和 MyISAM  
InnoDB 支持事务，MyISAM 不支持事务  
InnoDB 支持外键，MyISAM 不支持  
InnoDB 是聚集索引，MyISAM 是非聚集索引

6.什么是聚类什么是非聚类？
- https://zhuanlan.zhihu.com/p/86189418

7.MongoDB的底层数据结构是什么？
- B树

## **同步异步阻塞非阻塞**
1.同步和异步关注的是**消息通信机制**
- 所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该调用就不返回；  
而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果**。  
- 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。  
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

2.阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态**。
- 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回；  
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
- 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。  
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关

## **swap 虚拟内存**
1.什么是虚拟内存?
- 虚拟内存则是虚拟出来的、使用磁盘代替内存。memory就是机器的物理内存，读写速度低于cpu一个量级，但是高于磁盘不止一个量级。  
所以，程序和数据如果在内存的话，会有非常快的读写速度。内存的断电丢失数据是一个不能把所有数据和程序都保存在内存中对原因。  
当内存没有可用的，就必须要把内存中不经常运行的程序给踢出去。但是踢到哪里去，这时候swap就出现了。  
**swap全称为swap place，即交换区**，当内存不够的时候，被踢出的进程被暂时存储到交换区。当需要这条被踢出的进程的时候，就从交换区重新加载到内存，否则它不会主动交换到真实内存中。
