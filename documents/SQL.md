# MySQL

### 1、查询中尽量避免使用SELECT * 以及加上LIMIT限制

当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，
而不能简单的只取前面几条结果，然后让服务器停止发送。
查询应尽可能只返回必要数据，减小通信数据包大小和数量，提高效率。


### 2、IN 和 NOT IN 要慎用，会导致全表扫描。

MySQL优化器会选择代价最小的方式执行，IN和NOT IN 都可能索引失效，不是绝对的。


### 3、LIKE 导致全表扫描

LIKE导致索引失效是因为没遵循最佳左前缀法则。
字符串B-Tree排序方式：先按照第一个字母排序，如果第一个字母相同，就按照第二个字母排序，以此类推。

%号放右边 由于B-Tree的索引顺序，是按照首字母的大小进行排序，前缀匹配又是匹配首字母。所以可以在B+树上进行有序的查找，查找首字母符合要求的数据。所以有些时候可以用到索引。


### 4、联合索引需遵循最佳左前缀法则

GLS_CODE,BARCODE,SKU_ID 创建了联合索引，当查询语句where条件中没有GLS_CODE列不会走联合索引。创建这种多列联合索引时，列的顺序非常重要。 

B-Tree联合索引组合顺序与创建时列的顺序是一样的，第一个字段列的顺序是确定的，其他列的顺序都是不确定的。B-Tree索引的限制，如果查询不是按照索引创建时的顺序，则无法使用索引。

在查询中where条件里存在联合索引第一列，顺序不一致也是可以走索引的。这里是因为MySQL优化器会对查询重新排序。


### 5、不要在索引列上做任何操作

索引列存在计算、函数、类型转换，会导致索引失效进行全表扫描。


### 6、is null，is not null可能导致索引失效


### 7、要注意where,order by,group by后面的列，多表关联的列是否已加索引，优先考虑组合索引


### 8、where后面的列要注意隐式转换，会导致索引失效

不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较，最后导致索引失效。


### 9、count(*) 和 count(1) 的误解

https://dev.mysql.com/doc/refman/5.6/en/aggregate-functions.html#function_count

count(\*) 和 count(1) 效率是完全一样的，并没有count(1)会比count(\*)快的说法。